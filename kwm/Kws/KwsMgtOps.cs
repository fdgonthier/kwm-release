using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using Tbx.Utils;
using kwm.KwmAppControls;
using System.Windows.Forms;
using kwm.Utils;

namespace kwm
{
    /// <summary>
    /// Generic class for handling workspace operations that show
    /// a please wait dialog.
    /// </summary>
    public abstract class KwsPleaseWaitCoreOp : KwsCoreOp
    {
        /// <summary>
        /// Form asking the user to please wait.
        /// </summary>
        protected frmPleaseWait m_frmPleaseWait = new frmPleaseWait();

        /// <summary>
        /// Handle the completion of the operation.
        /// </summary>
        protected abstract void HandleCompletion(KwsCoreOpRes res, String failureReason);

        public KwsPleaseWaitCoreOp(WorkspaceManager wm) : base(wm) { }

        public override void HandleMiscFailure(Exception ex)
        {
            HandleCompletion(KwsCoreOpRes.MiscError, ex.Message);
        }

        /// <summary>
        /// Cancel the operation.
        /// </summary>
        public virtual void Cancel()
        {
            HandleCompletion(KwsCoreOpRes.Cancelled, "");
        }

        /// <summary>
        /// Show the please wait dialog. If the user asks to cancel the
        /// operation, do so. This method blocks until either the user cancels
        /// the dialog or the operation completes.
        /// </summary>
        protected void ShowPleaseWait()
        {
            DialogResult res = m_frmPleaseWait.ShowDialog();
            if (res == System.Windows.Forms.DialogResult.Cancel) Cancel();
        }

        /// <summary>
        /// Close the please wait form as required.
        /// </summary>
        protected void ClosePleaseWait()
        {
            if (m_frmPleaseWait != null)
            {
                m_frmPleaseWait.Close();
                m_frmPleaseWait.Dispose();
                m_frmPleaseWait = null;
            }
        }
    }
    
    /// <summary>
    /// Represent a generic command to change a property (either user or workspace).
    /// </summary>
    public abstract class SetPropertyCommand
    {
        /// <summary>
        /// ANP command.
        /// </summary>
        public AnpMsg Cmd;

        /// <summary>
        /// Failure reason if the command failed.
        /// </summary>
        public Exception FailureReason;

        /// <summary>
        /// Associated query made on the KAS.
        /// </summary>
        public WmKasQuery KasQuery;

        /// <summary>
        /// Event ID that will be generated by the KAS if this command succeeds.
        /// </summary>
        public UInt64 GeneratedResponseEvent = 0;

        /// <summary>
        /// Set to true when a response has been received for the KasQuery.
        /// </summary>
        public bool GotResponse = false;

        /// <summary>
        /// Return a human-readable string describing the command. Should be all
        /// in lower case.
        /// </summary>
        public abstract String CommandDesc { get; }
    }

    public class SetUserPropertyCommand : SetPropertyCommand
    {
        /// <summary>
        /// Action to take.
        /// </summary>
        private KwsUserAction Action;

        public override String CommandDesc
        {
            get { return Base.GetEnumDescription(Action); }
        }

        public SetUserPropertyCommand(Workspace kws, UInt32 targetUserId, KwsUserAction action)
        {
            Action = action;
            Cmd = kws.NewKAnpCmd(UserActionToAnpType(action));
            Cmd.AddUInt32(targetUserId);
        }

        /// <summary>
        /// Return the Anp command type corresponding to the action specified.
        /// </summary>
        private UInt32 UserActionToAnpType(KwsUserAction action)
        {
            switch (action)
            {
                case KwsUserAction.ChangeAdminFlag: return KAnpType.KANP_CMD_KWS_SET_USER_ADMIN;
                case KwsUserAction.ChangeLockFlag: return KAnpType.KANP_CMD_KWS_SET_USER_LOCK;
                case KwsUserAction.ChangeManagerFlag: return KAnpType.KANP_CMD_KWS_SET_USER_MANAGER;
                case KwsUserAction.Ban: return KAnpType.KANP_CMD_KWS_SET_USER_BAN;
                case KwsUserAction.ResetPassword: return KAnpType.KANP_CMD_KWS_SET_USER_PWD;
                case KwsUserAction.SetName: return KAnpType.KANP_CMD_KWS_SET_USER_NAME;
            }

            Debug.Assert(false);
            return 0;
        }
    }

    public class SetKwsPropertyCommand : SetPropertyCommand
    {
        /// <summary>
        /// Action to take.
        /// </summary>
        public KwsAction Action;

        public override string CommandDesc
        {
            get { return Base.GetEnumDescription(Action); }
        }

        public SetKwsPropertyCommand(Workspace kws, KwsAction action)
        {
            Action = action;
            Cmd = kws.NewKAnpCmd(KwsActionToAnpType(action));
        }

        /// <summary>
        /// Return the Anp command type corresponding to the action specified.
        /// </summary>
        private UInt32 KwsActionToAnpType(KwsAction action)
        {
            switch (action)
            {
                case KwsAction.ChangeDeepFreezeFlag: return KAnpType.KANP_CMD_KWS_SET_DEEP_FREEZE;
                case KwsAction.ChangeFreezeFlag: return KAnpType.KANP_CMD_KWS_SET_FREEZE;
                case KwsAction.ChangeSecureFlag: return KAnpType.KANP_CMD_KWS_SET_SECURE;
                case KwsAction.ChangeThinKfsFlag: return KAnpType.KANP_CMD_KWS_SET_THIN_KFS;
                case KwsAction.Rename: return KAnpType.KANP_CMD_KWS_SET_NAME;
            }

            Debug.Assert(false);
            return 0;
        }
    }

    /// <summary>
    /// Represent a core operation for setting one or more properties
    /// (user or workspace).
    /// </summary>
    public class SetPropertyOp : KwsPleaseWaitCoreOp
    {        
        /// <summary>
        /// List of the property change commands to perform.
        /// </summary>
        private List<SetPropertyCommand> m_commandList;

        protected override void HandleCompletion(KwsCoreOpRes res, String failureReason)
        {
            if (m_doneFlag) return;
            m_doneFlag = true;

            // Unregister from the workspace.
            UnregisterFromKws();

            // Cancel the KAS queries.
            foreach (SetPropertyCommand c in m_commandList)
            {
                if (c.KasQuery != null)
                {
                    c.KasQuery.Cancel();
                    c.KasQuery = null;
                }
            }

            // Post the GUI execution request.
            if (res != KwsCoreOpRes.Cancelled)
                m_kws.PostGuiExecRequest(new SetPropResults(m_kws, m_commandList, failureReason));

            ClosePleaseWait();
        }

        public SetPropertyOp(WorkspaceManager wm, List<SetPropertyCommand> commandList)
            : base(wm)
        {
            m_commandList = commandList;
        }

        /// <summary>
        /// Start the operation. Do not block the UI with Misc.OnUiEntry() 
        /// since this will block the GER execution that might be required by
        /// some commands (for example, password prompts).
        /// </summary>
        public void StartOp(Workspace kws)
        {
            m_kws = kws;
            RegisterToKws(false);

            // Post the commands.
            Debug.Assert(m_commandList.Count > 0);
            foreach (SetPropertyCommand c in m_commandList)
                c.KasQuery = m_kws.PostNonAppKasQuery(c.Cmd, null, HandleSetPropertyResponse, true);

            ShowPleaseWait();
        }

        /// <summary>
        /// Called when a response to one of the commands is received.
        /// </summary>
        protected void HandleSetPropertyResponse(KasQuery ctx)
        {
            if (m_doneFlag) return;

            // Get the associated command and mark it as done.
            SetPropertyCommand c = GetCommandByQuery(ctx);
            Debug.Assert(c != null);
            c.KasQuery = null;
            c.GotResponse = true;

            // Failure.
            if ((m_kws.Kas.MinorVersion < 4 && ctx.Res.Type != KAnpType.KANP_RES_OK) ||
                (m_kws.Kas.MinorVersion >= 4 && ctx.Res.Type != KAnpType.KANP_RES_KWS_PROP_CHANGE))
            {
                c.FailureReason = Misc.HandleUnexpectedKAnpReply(c.CommandDesc, ctx.Res);
            }

            // Success.
            else
            {
                // We have changed our own password. Save it.
                if (c.Cmd.Type == KAnpType.KANP_CMD_KWS_SET_USER_PWD &&
                    c.Cmd.Elements[1].UInt32 == m_kws.KwmUser.UserID)
                {
                    m_kws.CoreData.Credentials.Pwd = c.Cmd.Elements[2].String;
                    m_kws.SetDirty();
                }
            }

            // We're not done yet.
            foreach (SetPropertyCommand cmd in m_commandList) if (!cmd.GotResponse) return;

            // We're done.
            HandleCompletion(KwsCoreOpRes.Success, "");
        }

        /// <summary>
        /// Return the SetPropertyCommand associated to the given KasQuery.
        /// </summary>
        private SetPropertyCommand GetCommandByQuery(KasQuery q)
        {
            foreach (SetPropertyCommand c in m_commandList) if (c.KasQuery == q) return c;
            return null;
        }
    }

    /// <summary>
    /// GER required to let the user know the result of its user property
    /// changes.
    /// </summary>
    public class SetPropResults : GuiExecRequest
    {
        List<SetPropertyCommand> m_commands;
        String m_miscFailure;
        Workspace m_kws;

        public SetPropResults(Workspace kws, List<SetPropertyCommand> commands, String miscFailureString)
        {
            Debug.Assert(kws != null);
            m_kws = kws;
            m_commands = commands;
            m_miscFailure = miscFailureString;
        }

        public override void Run()
        {
            if (m_miscFailure != "")
            {
                Misc.KwmTellUser("Unable to complete your request: " + m_miscFailure, MessageBoxIcon.Error);
            }
            else
            {
                bool successFlag = true;
                bool switchToSecureFailed = false;

                foreach (SetPropertyCommand c in m_commands)
                {
                    if (c.FailureReason != null)
                    {
                        successFlag = false;
                        // Check if setting the Secure flag failed for a license
                        // restriction reason. If so, report it in a special way to 
                        // the user.
                        if (c is SetKwsPropertyCommand)
                        {
                            SetKwsPropertyCommand kwsCmd = c as SetKwsPropertyCommand;
                            if (kwsCmd.Action == KwsAction.ChangeSecureFlag &&
                                kwsCmd.Cmd.Elements[1].UInt32 == 1 &&
                                kwsCmd.FailureReason is LicenseRestrictionException)
                            {
                                switchToSecureFailed = true;
                            }
                        }
                    }                    
                }

                if (successFlag)
                    Misc.SetStatusBar(StatusBarIcon.OK, "The operation(s) completed successfully.");
                else
                {
                    if (switchToSecureFailed)
                    {
                        LicenseRestrictionMsgBox msg = new LicenseRestrictionMsgBox("Secure Teamboxes are not available with your license package.", m_kws.IsCreatorKwmUser);
                        WindowWrapper wrapper = new WindowWrapper(Misc.MainForm.Handle);
                        msg.ShowDialog(wrapper);
                    }

                    else
                    {
                        Misc.KwmTellUser("One or more operations failed. See below for details." +
                                         Environment.NewLine + Environment.NewLine +
                                         GetDetailedOperationsResult(), MessageBoxIcon.Error);
                    }
                }
            }
        }

        /// <summary>
        /// Return the text detailing the result of all the operations.
        /// </summary>
        private String GetDetailedOperationsResult()
        {
            String msg = "";
            foreach (SetPropertyCommand c in m_commands)
            {
                if (c.FailureReason == null)
                    msg += c.CommandDesc + ": Success.";
                else
                    msg += c.FailureReason.Message;

                msg += Environment.NewLine;
            }
            return msg;
        }
    }

    /// <summary>
    /// Workspace delete on server operation.
    /// </summary>
    public class KwsServerDeleteOp : KwsPleaseWaitCoreOp
    {
        public KwsServerDeleteOp(WorkspaceManager wm) :
            base(wm)
        {
        }

        public override void HandleDeferredNotification(object sender, EventArgs evt)
        {
            UpdateDeleteOnServerStepIfNeeded();
        }

        public override void HandleKasConnected()
        {
            UpdateDeleteOnServerStepIfNeeded();
        }

        public override void HandleKwsLoginSuccess()
        {
            HandleMiscFailure(new Exception("the server does not support " + Base.GetKwsString() + " deletion"));
        }

        public override void HandleKwsLogOut(Exception ex)
        {
            // This is the condition that we were expecting.
            if (ex != null &&
                m_kws.Sm.GetDeleteOnServerStep() == KwsDeleteOnServerStep.Login &&
                m_kws.KasLoginHandler.LoginResult == KwsLoginResult.DeletedKws)
            {
                HandleCompletion(KwsCoreOpRes.Success, "");
            }

            // Call the base handler.
            else
            {
                base.HandleKwsLogOut(ex);
            }
        }

        public override void HandleTaskSwitch(KwsTask task)
        {
            if (task != KwsTask.DeleteOnServer)
                HandleMiscFailure(new Exception("interrupted operation"));
        }

        protected override void HandleCompletion(KwsCoreOpRes res, String failureReason)
        {
            if (m_doneFlag) return;
            m_doneFlag = true;

            if (res == KwsCoreOpRes.Success)
            {
                // Remove the workspace locally.
                UnregisterAndRemoveKws();
            }

            else
            {
                // Unregister from the workspace.
                UnregisterFromKws();

                // Stop the workspace if it was created successfully, otherwise delete it.
                if (m_kws.MainStatus == KwsMainStatus.NotYetSpawned)
                    m_kws.Sm.RequestTaskSwitch(KwsTask.Remove);
                else
                    m_kws.Sm.RequestTaskSwitch(KwsTask.Stop);

                // Report the failure to the user.
                if (res != KwsCoreOpRes.Cancelled)
                {
                    m_kws.PostGuiExecRequest(new MiscGuiExecRequest(failureReason, Base.GetKwsString() + " deletion failed", MessageBoxIcon.Error));
                }
            }

            ClosePleaseWait();
        }

        /// <summary>
        /// Start the operation.
        /// </summary>
        public void StartOp(Workspace kws)
        {
            m_kws = kws;
            if (!RegisterToKws(true)) return;
            m_kws.Sm.RequestTaskSwitch(KwsTask.DeleteOnServer);
        }

        /// <summary>
        /// This method should be called when the delete on server step should
        /// be updated. This can be immediately after the task switch, when
        /// the KAS becomes connected or the workspace becomes logged out.
        /// </summary>
        private void UpdateDeleteOnServerStepIfNeeded()
        {
            if (m_doneFlag) return;
            if (m_kws.Kas.ConnStatus == KasConnStatus.Connected &&
                m_kws.LoginStatus == KwsLoginStatus.LoggedOut)
            {
                m_kws.Sm.SetDeleteOnServerStep(KwsDeleteOnServerStep.Login);
            }
        }
    }
}
